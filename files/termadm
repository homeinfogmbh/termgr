#! /usr/bin/env python3
"""Command line tool to administer HOMEINFO terminals.

Usage:
    termadm add <cid> [<street> <house_number> <zip_code> <city> \
[--state=<state_iso>] [--address-annotation=<annotation>]] \
[--scheduled=<date>] [options]
    termadm addall <cid> <file> [--scheduled=<date>] [options]
    termadm deploy <expr>... [--date=<date_string>] [--force] [options]
    termadm undeploy <expr>... [options]
    termadm relocate <terminal> <street> <house_number> <zip_code> <city> \
[--state=<state_iso>]
    termadm reload

Options:
    -h --help                   Show this screen.
    --version                   Show version.
    --domain=<domain>           Specifies the domain [default: 1].
    --connection=<connection>   Specifies connection type [default: 1].
    --tid=<tid>                 Explicitly selects a TID (not recommended!).
    --key=<key>                 Explicitly specifies an OpenVPN key to be used.
    --mtu=<mtu>                 Specifies the desired MTU size.
    --annotation=<annotation>   Specifies an annotation for the terminal.
    --no-reload                 Do not reload services after terminal creation.
    --class=<class>             Specifies the termianl class [default: 3].
    --os=<os>                   Specifies the termianl OS [default: 1].
    --weather=<weather>         Specifies the weather to use.
"""

from datetime import datetime
from os import geteuid
from pathlib import Path
from sys import exit as exit_

from peewee import DoesNotExist

from fancylog import LogLevel, Logger
from syslib import run, evaluate

from homeinfo.crm import Address, State
from terminallib import parse, PrintMissing, Class, Domain, OS, VPN, \
    Connection, Location, Terminal

DATE_FORMAT = '%Y-%m-%d'
NAGIOSCFG_GEN = '/usr/local/bin/nagioscfg-gen'
BINDCFG_GEN = '/usr/local/bin/bindcfg-gen'
OPENVPNCFG_GEN = '/usr/local/bin/openvpncfg-gen'


def update_nagios():
    """Generates the Nagios3 configuration."""

    print('Creating Nagios3 configurations', end='         ', flush=True)
    nagios_ok = run((NAGIOSCFG_GEN, '--restart'))
    evaluate(nagios_ok)
    return nagios_ok


def update_config():
    """Fix stuff after operations."""

    print('Generating bind9 configuration', end='          ', flush=True)
    bind_ok = run(BINDCFG_GEN)
    evaluate(bind_ok)
    print('Generating OpenVPN host configurations', end='  ', flush=True)
    openvpn_ok = run(OPENVPNCFG_GEN)
    evaluate(openvpn_ok)
    nagios_ok = update_nagios()
    return bind_ok and openvpn_ok and nagios_ok


def read_file(path):
    """Read address information from file."""

    with open(path, 'r') as file:
        for line in file:
            sline = line.strip()

            if sline:
                if not sline.startswith('#'):
                    yield sline


def parse_address(string, sep=' '):
    """Parses an address from a string"""

    elements = [e for e in string.split(sep) if e]

    try:
        *street, house_number, zip_code, city = elements
    except ValueError:
        raise ValueError('Not an address: {}'.format(string))
    else:
        return (city, (sep.join(street), house_number, zip_code))


def get_state(state_iso):
    """Gets the state by ISO code."""

    if state_iso:
        return State.get(State.iso == state_iso)


def add_terminal(options, logger, reload):
    """Adds a new terminal."""

    # Required options
    tid = int(options['--tid']) if options['--tid'] else None
    cid = int(options['<cid>'])
    class_id = int(options['--class'])
    os_id = int(options['--os'])

    if options['--scheduled']:
        scheduled = datetime.strptime(options['--scheduled'], DATE_FORMAT)
    else:
        scheduled = None

    # Optional settings
    connection_id = int(options['--connection'])
    domain_id = int(options['--domain'])
    weather = options['--weather'] or None

    # Optional address
    street = options['<street>']
    house_number = options['<house_number>']
    zip_code = options['<zip_code>']
    city = options['<city>']
    state_iso = options['--state']
    address_annotation = options['--address-annotation']

    if street:
        addr = (street, house_number, zip_code)
    else:
        addr = None

    try:
        state = get_state(state_iso)
    except DoesNotExist:
        logger.error('No such state: "{}".'.format(state_iso))
        return 1

    # Optional parameters
    vpn_key = options['--key'] or None

    try:
        mtu = int(options['--mtu'])
    except TypeError:
        mtu = None
    except ValueError:
        logger.error('Invalid MTU: {}.'.format(options['--mtu']))
        return 2

    annotation = options['--annotation'] or None

    # Get related ORM instances
    class_ = Class.get(Class.id == class_id)
    os = OS.get(OS.id == os_id)
    connection = Connection.get(Connection.id == connection_id)

    if vpn_key is not None:
        logger.warning('Divergent OpenVPN key specified: "{}"!'.format(
            vpn_key))

    vpn = VPN.add(key=vpn_key, mtu=mtu)
    domain = Domain.get(Domain.id == domain_id)

    if addr is not None:
        address = Address.add(city, addr=addr, state=state)
        location = Location.add(address, annotation=address_annotation)
    else:
        location = None

    # Add new terminal
    terminal = Terminal.add(
        cid, class_, os, connection, vpn, domain, location=location,
        weather=weather, scheduled=scheduled, annotation=annotation, tid=tid)

    if terminal:
        logger.info('Added terminal {}'.format(terminal))
    else:
        logger.error('Failed to add terminal')

    if reload:
        update_config()

    return 0


def add_terminals(options, logger, reload):
    """Adds multiple terminals from a file."""

    # Required options
    cid = int(options['<cid>'])
    path = options['<file>']
    class_id = int(options['--class'])
    os_id = int(options['--os'])
    connection_id = int(options['--connection'])
    domain_id = int(options['--domain'])
    weather = options['--weather'] or None

    if options['--scheduled']:
        scheduled = datetime.strptime(options['--scheduled'], DATE_FORMAT)
    else:
        scheduled = None

    # Get ORM references
    class_ = Class.get(Class.id == class_id)
    os = OS.get(OS.id == os_id)
    connection = Connection.get(Connection.id == connection_id)
    domain = Domain.get(Domain.id == domain_id)

    for line in read_file(path):
        try:
            city, addr = parse_address(line)
        except ValueError:
            logger.error('Not an address: {}'.format(line))
        else:
            # Generate unique VPN connection
            vpn = VPN.add()

            # Add location
            address = Address.add(city, addr=addr, state=None)
            location = Location.add(address)

            # Add new terminal
            terminal = Terminal.add(
                cid, class_, os, connection, vpn, domain, location=location,
                weather=weather, scheduled=scheduled)

            if terminal:
                logger.info('Added terminal {}'.format(terminal))
            else:
                logger.error('Failed to add terminal')

    if reload:
        update_config()

    return 0


def deploy(options, logger, reload):
    """Deploys terminals."""

    date_string = options['--date']
    force = options['--force']

    if date_string:
        try:
            date_time = datetime.strptime(date_string, DATE_FORMAT)
        except ValueError:
            logger.error(
                'Invalid date time value "{}" or format "{}".'.format(
                    date_string, DATE_FORMAT))
            return 4
    else:
        date_time = None

    with PrintMissing():
        for terminal in parse(*options['<expr>']):
            terminal.deploy(date_time=date_time, force=force)

    if reload:
        update_nagios()

    return 0


def undeploy(options, reload):
    """Removed deployment of terminals."""

    with PrintMissing():
        for terminal in parse(*options['<expr>']):
            terminal.undeploy()

    if reload:
        update_nagios()

    return 0


def relocate(options, logger):
    """Relocates a terminal."""

    with PrintMissing():
        terminal, *overhead = parse(options['<terminal>'])

    if overhead:
        print('Can only relocate one terminal at a time.')
        return 1
    else:
        street = options['<street>']
        house_number = options['<house_number>']
        zip_code = options['<zip_code>']
        city = options['<city>']
        state_iso = options['--state']

        addr = street, house_number, zip_code

        try:
            state = get_state(state_iso)
        except DoesNotExist:
            logger.error('No such state: "{}".'.format(state_iso))
            return 1

        address = Address.add(city, addr=addr, state=state)

        if terminal.location is None:
            terminal.location = Location.add(address)
            terminal.save()
            print('Initially located', terminal, 'at', repr(address))
        elif terminal.location.address == address:
            print(terminal, 'is already located at', repr(address))
        else:
            terminal.location.address = address
            terminal.location.save()
            print('Moved', terminal, 'to', repr(address))

        return 0


def main(options):
    """Runs the terminal administration CLI."""

    logger = Logger(Path(__file__).name, level=LogLevel.INFO)
    reload = not options['--no-reload']

    # Bail out iff reload of services
    # is required, but we are not root.
    if options['add'] or options['deploy'] or options['undeploy']:
        if reload and geteuid() != 0:
            logger.error('You must be root to update the related services.')
            return 3

    if options['add']:
        return add_terminal(options, logger, reload)
    elif options['addall']:
        return add_terminals(options, logger, reload)
    elif options['deploy']:
        return deploy(options, logger, reload)
    elif options['undeploy']:
        return undeploy(options, reload)
    elif options['relocate']:
        return relocate(options, logger)
    elif options['reload']:
        return 0 if update_config() else 1

    return 0


if __name__ == '__main__':
    from docopt import docopt
    exit_(main(docopt(__doc__)))
