#! /usr/bin/env python3
"""termadm.

  Command line tool to administer HOMEINFO terminals.

  (C) 2015-2016:  HOMEINFO - Digitale Informationssysteme GmbH

  Maintainer:     Richard Neumann <r.neumann@homeinfo.de>


Usage:
    termadm add <cid> [<street> <house_number> <zip_code> <city> \
[--state=<state_iso>] [--address-annotation=<annotation>]] \
[--scheduled=<date>] [options]
    termadm addall <cid> <file> [--scheduled=<date>] [options]
    termadm deploy <expr>... [--date=<date_string>] [--force] [options]
    termadm undeploy <expr>... [options]
    termadm relocate <terminal> <street> <house_number> <zip_code> <city> \
[--state=<state_iso>]
    termadm reload
    termadm notify

Options:
    --domain=<domain>           Specifies the domain [default: 1].
    --connection=<connection>   Specifies connection type [default: 1].
    --key=<key>                 Explicitly specifies an OpenVPN key to be used.
    --mtu=<mtu>                 Specifies the desired MTU size.
    --annotation=<annotation>   Specifies an annotation for the terminal.
    --no-reload                 Do not reload services after terminal creation.
    --class=<class>             Specifies the termianl class [default: 3].
    --os=<os>                   Specifies the termianl OS [default: 1].
    --weather=<weather>         Specifies the weather to use.
    --testing                   Mark this terminal as a testing terminal.
    --date-format=<format>      Specifies the date format to use.
    --version                   Show version.
    -h --help                   Show this screen.
"""
from collections import namedtuple
from datetime import datetime
from getpass import getuser
from logging import INFO, basicConfig, getLogger
from os import geteuid
from sys import exit as exit_

from homeinfo.crm import Address, State
from syslib import run, evaluate
from terminallib import parse, PrintErrors, Class, Domain, OS, VPN, \
    Connection, Location, Terminal

from termgr.notify import notify_users


LOG_FORMAT = '[%(levelname)s] %(name)s: %(message)s'
LOGGER = getLogger(__file__)
TERMGR_USER = 'termgr'
DATE_FORMAT = '%Y-%m-%d'
NAGIOSCFG_GEN = '/usr/local/bin/nagioscfg-gen'
BINDCFG_GEN = '/usr/local/bin/bindcfg-gen'
OPENVPNCFG_GEN = '/usr/local/bin/openvpncfg-gen'

Addr = namedtuple('Addr', ('street', 'house_number', 'zip_code'))
TerminalLine = namedtuple('TerminalLine', ('city', 'addr', 'scheduled'))


def update_nagios():
    """Generates the Nagios3 configuration."""

    print('Creating Nagios3 configurations', end='         ', flush=True)
    nagios_ok = run((NAGIOSCFG_GEN, '--restart'))
    evaluate(nagios_ok)
    return nagios_ok


def update_config():
    """Fix stuff after operations."""

    print('Generating bind9 configuration', end='          ', flush=True)
    bind_ok = run(BINDCFG_GEN)
    evaluate(bind_ok)
    print('Generating OpenVPN host configurations', end='  ', flush=True)
    openvpn_ok = run(OPENVPNCFG_GEN)
    evaluate(openvpn_ok)
    nagios_ok = update_nagios()
    return bind_ok and openvpn_ok and nagios_ok


def read_file(path):
    """Read non-comment lines from file."""

    with open(path, 'r') as file:
        for line in file:
            sline = line.strip()

            if sline:
                if not sline.startswith('#'):
                    yield sline


def parse_line(string, date_format=DATE_FORMAT):
    """Parses an address from a string."""

    try:
        address, scheduled = string.split('@')
    except ValueError:
        address = string
        scheduled = None
    else:
        address = address.strip()
        scheduled = datetime.strptime(scheduled.strip(), date_format).date()

    try:
        street_houseno, zip_code_city = address.split(',')
    except ValueError:
        street, house_number, zip_code, city = address.split()
    else:
        street_houseno = street_houseno.strip()
        zip_code_city = zip_code_city.strip()

        try:
            *street, house_number = street_houseno.split()
        except ValueError:
            raise ValueError('Not a street / house number: {}.'.format(
                street_houseno))

        street = ' '.join(street)

        if not street:
            street, house_number = house_number, None

        try:
            zip_code, city = zip_code_city.split()
        except ValueError:
            raise ValueError('Not a zip code / city: {}.'.format(zip_code_city))

    return TerminalLine(city, Addr(street, house_number, zip_code), scheduled)


def get_state(state_iso):
    """Gets the state by ISO code."""

    return State.get(State.iso == state_iso) if state_iso else None


def add_terminal(options):
    """Adds a new terminal."""

    # Required options.
    cid = int(options['<cid>'])
    class_id = int(options['--class'])
    os_id = int(options['--os'])

    if options['--scheduled']:
        scheduled = datetime.strptime(options['--scheduled'], DATE_FORMAT)
    else:
        scheduled = None

    # Optional settings.
    connection_id = int(options['--connection'])
    domain_id = int(options['--domain'])
    weather = options['--weather'] or None
    testing = options['--testing']

    # Optional address.
    street = options['<street>']
    house_number = options['<house_number>']
    zip_code = options['<zip_code>']
    city = options['<city>']
    state_iso = options['--state']
    address_annotation = options['--address-annotation']

    if street:
        addr = (street, house_number.rstrip(','), zip_code)
    else:
        addr = None

    try:
        state = get_state(state_iso)
    except State.DoesNotExist:
        LOGGER.error('No such state: "%s".', state_iso)
        return 1

    # Optional parameters
    vpn_key = options['--key'] or None

    try:
        mtu = int(options['--mtu'])
    except TypeError:
        mtu = None
    except ValueError:
        LOGGER.error('Invalid MTU: %s.', options['--mtu'])
        return 2

    annotation = options['--annotation'] or None

    # Get related ORM instances
    class_ = Class.get(Class.id == class_id)
    os_ = OS.get(OS.id == os_id)
    connection = Connection.get(Connection.id == connection_id)

    if vpn_key is not None:
        LOGGER.warning('Divergent OpenVPN key specified: "%s"!', vpn_key)

    vpn = VPN.add(key=vpn_key, mtu=mtu)
    domain = Domain.get(Domain.id == domain_id)

    if addr is not None:
        address = Address.add(city, addr=addr, state=state)
        location = Location.add(address, annotation=address_annotation)
    else:
        location = None

    terminal = Terminal.add(
        cid, class_, os_, connection, vpn, domain, location=location,
        weather=weather, scheduled=scheduled, annotation=annotation,
        testing=testing)

    if terminal:
        LOGGER.info('Added terminal %s.', terminal)
    else:
        LOGGER.error('Failed to add terminal.')

    if not options['--no-reload']:
        update_config()

    return 0


def add_terminals(options):
    """Adds multiple terminals from a file."""

    cid = int(options['<cid>'])
    path = options['<file>']
    class_id = int(options['--class'])
    os_id = int(options['--os'])
    connection_id = int(options['--connection'])
    domain_id = int(options['--domain'])
    weather = options['--weather'] or None
    date_format = options['--date-format'] or DATE_FORMAT

    if options['--scheduled']:
        scheduled = datetime.strptime(options['--scheduled'], date_format)
    else:
        scheduled = None

    class_ = Class.get(Class.id == class_id)
    os_ = OS.get(OS.id == os_id)
    connection = Connection.get(Connection.id == connection_id)
    domain = Domain.get(Domain.id == domain_id)
    retval = 0

    for line in read_file(path):
        try:
            city, addr, scheduled_ = parse_line(line, date_format=date_format)
        except ValueError as error:
            LOGGER.error(str(error))
            retval += 1
            continue

        vpn = VPN.add()
        address = Address.add(city, addr=addr, state=None)
        location = Location.add(address)
        terminal = Terminal.add(
            cid, class_, os_, connection, vpn, domain, location=location,
            weather=weather, scheduled=scheduled or scheduled_)

        if terminal:
            LOGGER.info('Added terminal %s.', terminal)
        else:
            LOGGER.error('Failed to add terminal.')

    if not options['--no-reload']:
        update_config()

    return retval


def deploy(options):
    """Deploys terminals."""

    date_string = options['--date']
    force = options['--force']

    if date_string:
        try:
            date_time = datetime.strptime(date_string, DATE_FORMAT)
        except ValueError:
            LOGGER.error(
                'Invalid date time value "%s" or format "%s".', date_string,
                DATE_FORMAT)
            return 4
    else:
        date_time = None

    with PrintErrors():
        for terminal in parse(*options['<expr>']):
            terminal.deploy(date_time=date_time, force=force)

    if not options['--no-reload']:
        update_nagios()

    return 0


def undeploy(options):
    """Removed deployment of terminals."""

    with PrintErrors():
        for terminal in parse(*options['<expr>']):
            terminal.undeploy()

    if not options['--no-reload']:
        update_nagios()

    return 0


def relocate(options):
    """Relocates a terminal."""

    with PrintErrors():
        terminal, *overhead = parse(options['<terminal>'])

    if overhead:
        print('Can only relocate one terminal at a time.')
        return 1

    street = options['<street>']
    house_number = options['<house_number>']
    zip_code = options['<zip_code>']
    city = options['<city>']
    state_iso = options['--state']

    addr = street, house_number, zip_code

    try:
        state = get_state(state_iso)
    except State.DoesNotExist:
        LOGGER.error('No such state: "%s".', state_iso)
        return 1

    address = Address.add(city, addr=addr, state=state)

    if terminal.location is None:
        terminal.location = Location.add(address)
        terminal.save()
        LOGGER.success('Initially located', terminal, 'at', repr(address))
    elif terminal.location.address == address:
        LOGGER.info(terminal, 'is already located at', repr(address))
    else:
        terminal.location.address = address
        terminal.location.save()
        LOGGER.success('Moved', terminal, 'to', repr(address))

    return 0


def main(options):
    """Runs the terminal administration CLI."""

    basicConfig(level=INFO, format=LOG_FORMAT)

    # Bail out iff reload of services
    # is required, but we are not root.
    if options['add'] or options['deploy'] or options['undeploy']:
        if not options['--no-reload'] and geteuid() != 0:
            LOGGER.error('You must be root to update the related services.')
            return 3

    if options['add']:
        return add_terminal(options)
    elif options['addall']:
        return add_terminals(options)
    elif options['deploy']:
        return deploy(options)
    elif options['undeploy']:
        return undeploy(options)
    elif options['relocate']:
        return relocate(options)
    elif options['reload']:
        return 0 if update_config() else 1
    elif options['notify']:
        if getuser() != TERMGR_USER and geteuid() != 0:
            # Because only termgr and root can read the certificates.
            LOGGER.error('You must be termgr or root to notify users.')
            return 3

        notify_users()

    return 0


if __name__ == '__main__':
    from docopt import docopt
    exit_(main(docopt(__doc__)))
