#! /usr/bin/env python3
"""termadm.

  Command line tool to administer HOMEINFO terminals.

  (C) 2015-2016:  HOMEINFO - Digitale Informationssysteme GmbH

  Maintainer:     Richard Neumann <r.neumann@homeinfo.de>


Usage:
    termadm add <cid> [<street> <house_number> <zip_code> <city> \
[--state=<state_iso>] [--annotation=<annotation>]] \
[--scheduled=<date>] [options]
    termadm addall <cid> <file> [--scheduled=<date>] [options]
    termadm deploy <expr>... [--date=<date_string>] [--force] [options]
    termadm undeploy <expr>... [options]
    termadm relocate <terminal> <street> <house_number> <zip_code> <city> \
[--state=<state_iso>]
    termadm reload
    termadm notify [<account>...]

Options:
    --domain=<domain>           Specifies the domain [default: 1].
    --connection=<connection>   Specifies connection type [default: 1].
    --key=<key>                 Explicitly specifies an OpenVPN key to be used.
    --mtu=<mtu>                 Specifies the desired MTU size.
    --annotation=<annotation>   Specifies an annotation for the terminal.
    --no-reload                 Do not reload services after terminal creation.
    --class=<class>             Specifies the termianl class [default: 3].
    --os=<os>                   Specifies the termianl OS [default: 1].
    --weather=<weather>         Specifies the weather to use.
    --testing                   Mark this terminal as a testing terminal.
    --date-format=<format>      Specifies the date format to use.
    --version                   Show version.
    -h --help                   Show this screen.
"""
from datetime import datetime
from getpass import getuser
from logging import INFO, basicConfig, getLogger
from os import geteuid
from sys import exit as exit_

from docopt import docopt

from his import Account
from mdb import Address, State
from syslib import run, evaluate, script
from terminallib import get_terminals, Class, Domain, OS, VPN, Connection, \
    Terminal
from timelib import DATE_FORMAT

from termgr.config import LOG_FORMAT
from termgr.notify import notify_accounts
from termgr.util import Addr, TerminalLine


LOGGER = getLogger(__file__)
TERMGR_USER = 'termgr'
NAGIOSCFG_GEN = '/usr/local/bin/nagioscfg-gen'
BINDCFG_GEN = '/usr/local/bin/bindcfg-gen'
OPENVPNCFG_GEN = '/usr/local/bin/openvpncfg-gen'


def _get_accounts(accounts):
    """Yields the respective users."""

    for account in accounts:
        try:
            yield Account.get(Account.name == account)
        except Account.DoesNotExist:
            LOGGER.warning('No such account: %s.', account)


def update_nagios():
    """Generates the Nagios3 configuration."""

    print('Creating Nagios3 configurations', end='         ', flush=True)
    nagios_ok = run((NAGIOSCFG_GEN, '--restart'))
    evaluate(nagios_ok)
    return nagios_ok


def update_config():
    """Fix stuff after operations."""

    print('Generating bind9 configuration', end='          ', flush=True)
    bind_ok = run(BINDCFG_GEN)
    evaluate(bind_ok)
    print('Generating OpenVPN host configurations', end='  ', flush=True)
    openvpn_ok = run(OPENVPNCFG_GEN)
    evaluate(openvpn_ok)
    nagios_ok = update_nagios()
    return bind_ok and openvpn_ok and nagios_ok


def read_file(path):
    """Read non-comment lines from file."""

    with open(path, 'r') as file:
        for line in file:
            sline = line.strip()

            if sline:
                if not sline.startswith('#'):
                    yield sline


def parse_line(string, date_format=DATE_FORMAT):
    """Parses an address from a string."""

    try:
        address, scheduled = string.split('@')
    except ValueError:
        address = string
        scheduled = None
    else:
        address = address.strip()
        scheduled = datetime.strptime(scheduled.strip(), date_format).date()

    try:
        street_houseno, zip_code_city = address.split(',')
    except ValueError:
        street, house_number, zip_code, city = address.split()
    else:
        street_houseno = street_houseno.strip()
        zip_code_city = zip_code_city.strip()

        try:
            street, house_number = street_houseno.rsplit(maxsplit=1)
        except ValueError:
            raise ValueError('Not a street / house number: {}.'.format(
                street_houseno))

        if not street:
            street, house_number = house_number, None

        try:
            zip_code, city = zip_code_city.split()
        except ValueError:
            raise ValueError('Not a zip code / city: {}.'.format(
                zip_code_city))

    return TerminalLine(city, Addr(street, house_number, zip_code), scheduled)


def get_state(state_iso):
    """Gets the state by ISO code."""

    return State.get(State.iso == state_iso) if state_iso else None


def add_terminal(options):
    """Adds a new terminal."""

    # Required options.
    cid = int(options['<cid>'])
    class_id = int(options['--class'])
    os_id = int(options['--os'])

    if options['--scheduled']:
        scheduled = datetime.strptime(options['--scheduled'], DATE_FORMAT)
    else:
        scheduled = None

    # Optional settings.
    connection_id = int(options['--connection'])
    domain_id = int(options['--domain'])
    weather = options['--weather'] or None
    testing = options['--testing']

    # Optional address.
    street = options['<street>']
    house_number = options['<house_number>']
    zip_code = options['<zip_code>']
    city = options['<city>']
    state_iso = options['--state']

    if street:
        addr = (street, house_number.rstrip(','), zip_code)
    else:
        addr = None

    try:
        state = get_state(state_iso)
    except State.DoesNotExist:
        LOGGER.error('No such state: "%s".', state_iso)
        return 1

    # Optional parameters
    vpn_key = options['--key'] or None

    try:
        mtu = int(options['--mtu'])
    except TypeError:
        mtu = None
    except ValueError:
        LOGGER.error('Invalid MTU: %s.', options['--mtu'])
        return 2

    annotation = options['--annotation'] or None

    # Get related ORM instances
    class_ = Class.get(Class.id == class_id)
    os_ = OS.get(OS.id == os_id)
    connection = Connection.get(Connection.id == connection_id)

    if vpn_key is not None:
        LOGGER.warning('Divergent OpenVPN key specified: "%s"!', vpn_key)

    vpn = VPN.add(key=vpn_key, mtu=mtu)
    domain = Domain.get(Domain.id == domain_id)

    if addr is not None:
        address = Address.add(city, addr=addr, state=state)
        address.save()
    else:
        address = None

    terminal = Terminal.add(
        cid, class_, os_, connection, vpn, domain, address=address,
        weather=weather, scheduled=scheduled, annotation=annotation,
        testing=testing)

    if terminal:
        LOGGER.info('Added terminal %s.', terminal)
    else:
        LOGGER.error('Failed to add terminal.')

    if not options['--no-reload']:
        update_config()

    return 0


def add_terminals(options):
    """Adds multiple terminals from a file."""

    cid = int(options['<cid>'])
    path = options['<file>']
    class_id = int(options['--class'])
    os_id = int(options['--os'])
    connection_id = int(options['--connection'])
    domain_id = int(options['--domain'])
    weather = options['--weather'] or None
    date_format = options['--date-format'] or DATE_FORMAT

    if options['--scheduled']:
        scheduled = datetime.strptime(options['--scheduled'], date_format)
    else:
        scheduled = None

    class_ = Class.get(Class.id == class_id)
    os_ = OS.get(OS.id == os_id)
    connection = Connection.get(Connection.id == connection_id)
    domain = Domain.get(Domain.id == domain_id)
    retval = 0

    for line in read_file(path):
        try:
            city, addr, scheduled_ = parse_line(line, date_format=date_format)
        except ValueError as error:
            LOGGER.error(str(error))
            retval += 1
            continue

        vpn = VPN.add()
        address = Address.add(city, addr=addr, state=None)
        address.save()
        terminal = Terminal.add(
            cid, class_, os_, connection, vpn, domain, address=address,
            weather=weather, scheduled=scheduled or scheduled_)

        if terminal:
            LOGGER.info('Added terminal %s.', terminal)
        else:
            LOGGER.error('Failed to add terminal.')

    if not options['--no-reload']:
        update_config()

    return retval


def deploy(options):
    """Deploys terminals."""

    date_string = options['--date']
    force = options['--force']

    if date_string:
        try:
            date_time = datetime.strptime(date_string, DATE_FORMAT)
        except ValueError:
            LOGGER.error(
                'Invalid date time value "%s" or format "%s".', date_string,
                DATE_FORMAT)
            return 4
    else:
        date_time = None

    for terminal in get_terminals(options['<expr>']):
        terminal.deploy(date_time=date_time, force=force)

    if not options['--no-reload']:
        update_nagios()

    return 0


def undeploy(options):
    """Removed deployment of terminals."""

    for terminal in get_terminals(options['<expr>']):
        terminal.undeploy()

    if not options['--no-reload']:
        update_nagios()

    return 0


def relocate(options):
    """Relocates a terminal."""

    try:
        terminal, *overhead = get_terminals([options['<terminal>']])
    except ValueError:
        LOGGER.error('No terminal found.')
        return 1

    if overhead:
        LOGGER.error('Can only relocate one terminal at a time.')
        return 2

    street = options['<street>']
    house_number = options['<house_number>']
    zip_code = options['<zip_code>']
    city = options['<city>']
    state_iso = options['--state']
    addr = (street, house_number, zip_code)

    try:
        state = get_state(state_iso)
    except State.DoesNotExist:
        LOGGER.error('No such state: %s.', state_iso)
        return 3

    address = Address.add(city, addr=addr, state=state)
    address.save()

    if terminal.address is None:
        terminal.address = address
        LOGGER.info('Initially located %s at %s.', terminal, address)
    elif terminal.address == address:
        LOGGER.info('%s is already located at %s.', terminal, address)
    else:
        address, terminal.address = terminal.address, address
        LOGGER.info(
            'Moved %s from %s to %s.', terminal, address, terminal.address)

    terminal.save()
    return 0


def notify(options):
    """Notifies the respective users."""

    if getuser() != TERMGR_USER and geteuid() != 0:
        # Because only termgr and root can read the certificates.
        LOGGER.error('You must be termgr or root to notify users.')
        return 3

    if options['<account>']:
        accounts = tuple(_get_accounts(options['<account>']))
    else:
        accounts = None

    notify_accounts(accounts=accounts)
    return 0


@script
def main(options):
    """Runs the terminal administration CLI."""

    basicConfig(level=INFO, format=LOG_FORMAT)

    # Bail out iff reload of services
    # is required, but we are not root.
    if options['add'] or options['deploy'] or options['undeploy']:
        if not options['--no-reload'] and geteuid() != 0:
            LOGGER.error('You must be root to update the related services.')
            return 3

    if options['add']:
        return add_terminal(options)

    if options['addall']:
        return add_terminals(options)

    if options['deploy']:
        return deploy(options)

    if options['undeploy']:
        return undeploy(options)

    if options['relocate']:
        return relocate(options)

    if options['reload']:
        return 0 if update_config() else 1

    if options['notify']:
        return notify(options)

    return 0


if __name__ == '__main__':
    exit_(main(docopt(__doc__)))
