#! /usr/bin/env python3
"""termgr.

  Command line tool to manage HOMEINFO terminals.

  (C) 2015-2016:  HOMEINFO - Digitale Informationssysteme GmbH

  Maintainer:     Richard Neumann <r.neumann@homeinfo.de>


Usage:
    termgr update <expr>... [options]
    termgr stage <expr>... [options]
    termgr sync <packages> <expr>... [--asexplicit] [options]
    termgr system-upgrade <expr>... [options]
    termgr (reboot | chkres | unlock) <expr>... [options]

Options:
    --help, -h                  Show this screen.
    --version, -V               Show version.
    --verbose, -v               Be gassy.
    --undeployed, -n            Select undeployed terminals.
    --testing, -t               Select only testing terminals.
    --classes=<classes>, -c     Select terminals of the respective classes.
    --oss=<os>, -o              Select terminals of the respective operating
                                systems.
    --user=<user>, -u           Specify user account for SSH connections.
"""
from getpass import getuser
from logging import INFO, basicConfig, getLogger
from os import geteuid
from sys import exit as exit_

from docopt import docopt

from fancylog import DEFAULT_ANIMATION, TTYAnimation, TTYAnimator
from syslib import Parallelization
from terminallib import get_terminals

from termgr.config import LOG_FORMAT
from termgr.ctrl import TerminalsController


LOGGER = getLogger(__file__)
TERMGR_USER = 'termgr'


def main(options):
    """Runs the terminal manager."""

    basicConfig(level=INFO, format=LOG_FORMAT)

    if geteuid() == 0:
        LOGGER.error('Refusing to run as root.')
        return 3
    elif getuser() != TERMGR_USER:
        LOGGER.error('You must be %s to run %s.', TERMGR_USER, __file__)
        return 2

    deployed = None if options['--undeployed'] else True
    classes = options['--classes'].split(',') if options['--classes'] else None
    oss = options['--oss'].split(',') if options['--oss'] else None
    terminals = tuple(get_terminals(
        options['<expr>'], deployed=deployed, testing=options['--testing'],
        classes=classes, oss=oss))

    ctrl = TerminalsController()

    # Perform selected operation.
    if options['update']:
        animation = TTYAnimation(
            'Updating {}: {}', DEFAULT_ANIMATION.stages,
            DEFAULT_ANIMATION.end)

        with Parallelization(ctrl.update, terminals, single=True) as para:
            with TTYAnimator(para, animation=animation):
                para.wait()

        for terminal, *_ in para.failures:
            LOGGER.error('Failed to update %s.', terminal)
    elif options['stage']:
        animation = TTYAnimation(
            'Staging {}: {}', DEFAULT_ANIMATION.stages,
            DEFAULT_ANIMATION.end)

        with Parallelization(ctrl.stage, terminals, single=True) as para:
            with TTYAnimator(para, animation=animation):
                para.wait()

        for terminal, *_ in para.failures:
            LOGGER.error('Failed to stage %s.', terminal)
    elif options['sync']:
        pkgs = options['<packages>'].split(',')
        install = ctrl.install(*pkgs, asexplicit=options['--asexplicit'])
        animation = TTYAnimation(
            'Syncing {}: {}', DEFAULT_ANIMATION.stages,
            DEFAULT_ANIMATION.end)

        with Parallelization(install, terminals, single=True) as para:
            with TTYAnimator(para, animation=animation):
                para.wait()

        for terminal, *_ in para.failures:
            LOGGER.error('Failed to sync %s.', terminal)
    elif options['system-upgrade']:
        animation = TTYAnimation(
            'Upgrading {}: {}', DEFAULT_ANIMATION.stages,
            DEFAULT_ANIMATION.end)

        with Parallelization(ctrl.upgrade, terminals, single=True) as para:
            with TTYAnimator(para, animation=animation):
                para.wait()

        for terminal, *_ in para.failures:
            LOGGER.error('Failed to upgrade %s.', terminal)
    elif options['reboot']:
        animation = TTYAnimation(
            'Rebooting {}: {}', DEFAULT_ANIMATION.stages,
            DEFAULT_ANIMATION.end)

        with Parallelization(ctrl.reboot, terminals, single=True) as para:
            with TTYAnimator(para, animation=animation):
                para.wait()
    elif options['chkres']:
        animation = TTYAnimation(
            'Checking resolution {}: {}', DEFAULT_ANIMATION.stages,
            DEFAULT_ANIMATION.end)

        with Parallelization(ctrl.chkres, terminals, single=True) as para:
            with TTYAnimator(para, animation=animation):
                para.wait()
    elif options['unlock']:
        animation = TTYAnimation(
            'Unlocking {}: {}', DEFAULT_ANIMATION.stages,
            DEFAULT_ANIMATION.end)

        with Parallelization(ctrl.unlock, terminals, single=True) as para:
            with TTYAnimator(para, animation=animation):
                para.wait()

        for terminal, *_ in para.failures:
            LOGGER.error('Failed to unlock %s.', terminal)

    return 0


if __name__ == '__main__':
    exit_(main(docopt(__doc__)))
