#! /usr/bin/env python3
"""Command line tool to manage HOMEINFO terminals

  (C) 2015-2016:  HOMEINFO - Digitale Informationssysteme GmbH

  Maintainer:     Richard Neumann <r.neumann@homeinfo.de>


Usage:
    termgr (upgrade | reboot | unlock | chkres) <expr> [options]
    termgr fixpkg <expr> <pkgs>...
    termgr chkinitcpio <expr> [--modules] [--hooks] [--compression] [options]
    termgr chkpacman <expr> [--siglevel] [options]

Options:
    -h --help       Show this screen.
    --version       Show version.
    --verbose       Be gassy.
    --undeployed    Also handle undeployed terminals.
    --user=<user>   Specify user account for SSH connections.
"""

from os import geteuid
from sys import stderr
from getpass import getuser
from logging import INFO, getLogger, basicConfig
from os.path import basename

from homeinfo.lib.system import Parallelization, Watchdog

from homeinfo.terminals.ctrl import RemoteController
from homeinfo.terminals.filter import TerminalFilter
from homeinfo.terminals.orm import Terminal

from termgr.lib.cmds import TERMGR_USER, PackageManagerCommand,\
    CheckInitcpioConfig, CheckPacmanConfig, Commands
from termgr.lib.filter import deployed, online
from termgr.lib.tui import printterm


VERBOSE = False


# ### Command wrappers ### #
def upgrade(terminal):
    """Upgrades a terminal"""

    logger.info('Upgrading: {}'.format(terminal))
    result = Commands.UPGRADE(terminal)

    if result:
        logger.debug('Upgraded: {}'.format(terminal))
    else:
        logger.error('Upgrade failed: {}'.format(terminal))

        if VERBOSE:
            printterm(terminal, result)


def reboot(terminal):
    """Reboots a terminal"""

    logger.info('Rebooting: {}'.format(terminal))
    Commands.REBOOT(terminal)


if __name__ == '__main__':
    from docopt import docopt

    options = docopt(__doc__)
    logger = getLogger(basename(__file__))
    basicConfig(level=INFO)

    if geteuid() == 0:
        print('Refusing to run as root')
        exit(3)
    elif getuser() != TERMGR_USER:
        print('You must be {0} to run {1}'.format(
            TERMGR_USER, __file__), file=stderr)
        exit(2)
    else:
        USER = options['--user'] if options['--user'] else TERMGR_USER
        VERBOSE = options['--verbose']

        # Get terminals generator
        if not options['<expr>']:
            terminals = Terminal.select().where(
                ~(Terminal.deployed >> None) &
                (Terminal.testing == 0))
        else:
            terminals = TerminalFilter(options['<expr>'])

        # Filter out undeployed terminals
        if not options['--undeployed']:
            terminals = deployed(terminals, logger=logger)

        # Perform selected operation
        if options['upgrade']:
            with Parallelization(
                    upgrade,
                    terminals,
                    blocking=False,
                    single=True) as para:
                with Watchdog() as doggy:
                    doggy.start(para.threads)
        elif options['reboot']:
            with Parallelization(
                    reboot,
                    terminals,
                    blocking=False,
                    single=True) as para:
                with Watchdog() as doggy:
                    doggy.start(para.threads)
        elif options['unlock']:
            with Parallelization(
                    Commands.UNLOCK,
                    terminals,
                    blocking=False,
                    single=True) as para:
                with Watchdog() as doggy:
                    doggy.start(para.threads)
        elif options['chkres']:
            for terminal in online(terminals):
                printterm(terminal, Commands.CHKRES(terminal))
        elif options['fixpkg']:
            packages = options['<pkgs>'] or PackageManagerCommand.BASE_PKGS
            fix_packages = PackageManagerCommand(
                packages, '--asexplicit', '-S')

            with Parallelization(
                    fix_packages,
                    terminals,
                    blocking=False,
                    single=True) as para:
                with Watchdog() as doggy:
                    doggy.start(para.threads)
        elif options['chkinitcpio']:
            modules = options['--modules']
            hooks = options['--hooks']
            compression = options['--compression']
            chk_initcpio = CheckInitcpioConfig(
                modules=modules,
                hooks=hooks,
                compression=compression)

            for terminal in online(terminals):
                chk_initcpio(terminal)
        elif options['chkpacman']:
            siglevel = options['--siglevel']
            chk_pacman = CheckPacmanConfig(siglevel=siglevel)

            for terminal in online(terminals):
                chk_pacman(terminal)
