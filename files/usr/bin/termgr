#! /usr/bin/env python3
"""Command line tool to administer HOMEINFO terminals

Usage:
    termgr add <class_id> <cid> [<street> <house_number> <zip_code> \
<city> [--state=<state_iso>]] [--tid=<tid>]
    termgr (upgrade | reboot | unlock) <expr>

Options:
    -h --help     Show this screen.
    --version     Show version.
"""

from os import listdir, chmod, geteuid
from os.path import join
from sys import stderr
from threading import Thread
from itertools import chain

from docopt import docopt

from homeinfo.lib.system import run, evaluate
from homeinfo.crm import Address, State
from homeinfo.terminals.filter import TerminalFilter
from homeinfo.terminals.config import terminals_config
from homeinfo.terminals.ctrl import RemoteController
from homeinfo.terminals.db import Terminal, Class, Domain

from termgr.lib.openvpn import OpenVPNKeyMgr
from termgr.lib.err import KeyExists, KeygenError


def add_terminal(options):
    """Adds a new terminal"""
    class_id_str = options['<class_id>']
    cid_str = options['<cid>']
    tid_str = options['--tid']
    street = options['<street>']
    house_number = options['<house_number>']
    zip_code = options['<zip_code>']
    city = options['<city>']
    state_iso = options['--state']
    class_id = int(class_id_str)
    cid = int(cid_str)
    if tid_str is not None:
        desired_tid = int(tid_str)
    else:
        desired_tid = None
    tid = Terminal.gen_tid(cid, desired=desired_tid)
    class_ = Class.get(Class.id == class_id)
    domain = Domain.get(Domain.id == 1)  # TODO: Make this dynamic
    if state_iso:
        state = State.get(State._iso == state_iso)
    else:
        state = None
    addr = (street, house_number, zip_code)
    if None not in chain([city], addr):
        address = Address.add(city, addr=addr, state=state)
    else:
        address = None
    terminal = Terminal()
    terminal.customer = cid
    terminal.tid = tid
    terminal.class_ = class_
    terminal.domain = domain
    terminal.ipv4addr = Terminal.gen_ipv4addr()
    terminal.virtual_display = None
    terminal.location = address
    terminal.deleted = None
    print('Created terminal record for host name:', terminal.hostname,
          'with id:', terminal.id)
    key_manager = OpenVPNKeyMgr(terminal)
    try:
        key_name = key_manager.generate()
    except KeyExists:
        print('OpenVPN keys already present')
    except KeygenError:
        print('Could not generate new OpenVPN Key')
    else:
        print('OpenVPN keys generated')
    terminal.vpn_key = key_name
    terminal.save()
    restart_services()


def restart_services():
    """Fix stuff after operations"""
    print('Fixing VPN permissions', end='                  ', flush=True)
    ok = True
    for file in listdir(terminals_config.openvpn['KEYS_DIR']):
        try:
            chmod(join(terminals_config.openvpn['KEYS_DIR'], file), 0o660)
        except:
            ok = False
    evaluate(ok)
    print('Generating bind9 configuration', end='          ', flush=True)
    evaluate(run('/usr/lib/terminals/bind.gen'))
    print('Generating OpenVPN host configurations', end='  ', flush=True)
    evaluate(run('/usr/lib/terminals/openvpn-client-config.gen'))
    print('Creating Nagios3 configurations', end='         ', flush=True)
    evaluate(run('/usr/lib/terminals/nagios-config.gen'))


def upgrade(terminal):
    """Upgrades a terminal"""
    if terminal.status:
        print('Upgrading', terminal)
        rc = RemoteController('termgr', terminal)
        pr = rc.execute(
            '/usr/bin/sudo', '/usr/bin/pacman', '-Syu', '--noconfirm')
        if pr:
            print('Upgraded', terminal)
        else:
            print('ERROR:', 'Failed to upgrade', terminal, file=stderr)
            print(pr, file=stderr)
    else:
        print('WARNING: Terminal', terminal, 'is offline', file=stderr)


def rm_pacman_lock(terminal):
    """Removes the pacman lockfile"""
    if terminal.status:
        print('Removing pacman lockfile on', terminal)
        rc = RemoteController('termgr', terminal)
        pr = rc.execute(
            '/usr/bin/sudo', '/usr/bin/rm', '-f ', '/var/lib/pacman/db.lck')
        if pr:
            print('Removed pacman lockfile on', terminal)
        else:
            print('ERROR:', 'Failed to remove pacman lockfile on',
                  terminal, file=stderr)
            print(pr, file=stderr)
    else:
        print('WARNING: Terminal', terminal, 'is offline', file=stderr)


def reboot(terminal):
    """Reboots a terminal"""
    if terminal.status:
        print('Rebooting terminal:', terminal)
        rc = RemoteController('termgr', terminal)
        rc.execute('/usr/bin/sudo', '/usr/bin/reboot')
    else:
        print('WARNING: Terminal', terminal, 'is offline', file=stderr)


def multithread(terminals, target):
    """Run processes for multiple terminals in parallel"""
    threads = []
    for terminal in terminals:
        thread = Thread(target=target, args=[terminal])
        threads.append(thread)
        thread.start()
    for thread in threads:
        thread.join()


if __name__ == '__main__':
    options = docopt(__doc__)
    if options['add']:
        if geteuid() == 0:
            add_terminal(options)
        else:
            print('You must be root to add new terminals')
            exit(3)
    else:
        expr = options['<expr>']
        if options['upgrade']:
            terminals = TerminalFilter(expr)
            multithread(terminals, upgrade)
        elif options['reboot']:
            terminals = TerminalFilter(expr)
            multithread(terminals, reboot)
        elif options['unlock']:
            terminals = TerminalFilter(expr)
            multithread(terminals, rm_pacman_lock)
