#! /usr/bin/env python3
"""Command line tool to manage HOMEINFO terminals

  (C) 2015-2016:  HOMEINFO - Digitale Informationssysteme GmbH

  Maintainer:     Richard Neumann <r.neumann@homeinfo.de>


Usage:
    termgr (upgrade | reboot | unlock | chkres) <expr> [options]
    termgr fixpkg <expr> <pkgs>...
    termgr chkinitcpio <expr> [--modules] [--hooks] [--compression] [options]
    termgr chkpacman <expr> [--siglevel] [options]

Options:
    -h --help       Show this screen.
    --version       Show version.
    --verbose       Be gassy.
    --undeployed    Also handle undeployed terminals.
    --user=<user>   Specify user account for SSH connections.
"""

from os import geteuid
from sys import stderr
from getpass import getuser

from docopt import docopt

from homeinfo.lib.system import parallelize

from homeinfo.terminals.ctrl import RemoteController
from homeinfo.terminals.filter import TerminalFilter
from homeinfo.terminals.orm import Terminal

USER = 'termgr'
VERBOSE = False


def deployed(terminals):
    """Yields deployed terminals"""
    for terminal in terminals:
        if terminal.deployed:
            yield terminal
        else:
            print('WARNING: Terminal', terminal, 'is not deployed', file=stderr)


def online(terminals):
    """Yields online terminals"""
    for terminal in terminals:
        if terminal.status:
            yield terminal
        else:
            print('WARNING: Terminal', terminal, 'is offline', file=stderr)


def itemize(terminals):
    """Returns a list of listed terminals for parallel processing"""
    return [[terminal] for terminal in terminals]


def upgrade(terminal):
    """Upgrades a terminal"""
    if terminal.status:
        print('Upgrading', terminal, file=stderr)
        rc = RemoteController('termgr', terminal)
        pr = rc.execute(
            '/usr/bin/sudo', '/usr/bin/pacman', '-Syu', '--noconfirm')
        if pr:
            print('Upgraded', terminal)
        else:
            print('ERROR:', 'Failed to upgrade', terminal, file=stderr)
            if VERBOSE:
                print(pr, file=stderr)
    else:
        print('WARNING: Terminal', terminal, 'is offline', file=stderr)


def reboot(terminal):
    """Reboots a terminal"""
    if terminal.status:
        print('Rebooting terminal:', terminal, file=stderr)
        rc = RemoteController('termgr', terminal)
        rc.execute('/usr/bin/sudo', '/usr/bin/reboot')
    else:
        print('WARNING: Terminal', terminal, 'is offline', file=stderr)


def rm_pacman_lock(terminal):
    """Removes the pacman lockfile"""
    if terminal.status:
        print('Removing pacman lockfile on', terminal, file=stderr)
        rc = RemoteController('termgr', terminal)
        pr = rc.execute(
            '/usr/bin/sudo', '/usr/bin/rm', '-f ', '/var/lib/pacman/db.lck')
        if pr:
            print('Removed pacman lockfile on', terminal)
        else:
            print('ERROR:', 'Failed to remove pacman lockfile on',
                  terminal, file=stderr)
            if VERBOSE:
                print(pr, file=stderr)
    else:
        print('WARNING: Terminal', terminal, 'is offline', file=stderr)


def chkres(terminal):
    """Checks terminal screen resolutions"""
    rc = RemoteController(USER, terminal)
    pr = rc.execute('export DISPLAY=:0 \; xrandr | grep " connected"')
    if pr:
        print('Resolution on: ', terminal, '\t',
              pr.stdout.decode().strip(), sep='')
    else:
        print('Could not determine resolution on:', terminal, file=stderr)
        if VERBOSE:
            print(pr, file=stderr)


def fixpkg(terminal, packages=None):
    """Make packages explicitly installed"""
    packages = packages or []
    rc = RemoteController(USER, terminal)
    print('Explicitly installing', *packages, 'on:', terminal)
    pr = rc.execute(
        '/usr/bin/sudo', '/usr/bin/pacman', '-S',
        *packages, '--asexplicit')
    if pr:
        print('Resolution on: ', terminal, '\t',
              pr.stdout.decode().strip(), sep='')
    else:
        print('Could not determine resolution on:', terminal, file=stderr)
        if VERBOSE:
            print(pr, file=stderr)


def chkinitcpio(terminal, modules=False, hooks=False, compression=False):
    """Print certain settings of the /etc/initcpio.conf"""
    print('Checking /etc/mkinitcpio.conf on', terminal, file=stderr)
    rc = RemoteController('termgr', terminal)
    if modules:
        pr = rc.execute(
            '/usr/bin/grep', '^MODULES=', '/etc/mkinitcpio.conf')
        print(pr.stdout.decode(), end='')
    if hooks:
        pr = rc.execute(
            '/usr/bin/grep', '^HOOKS=', '/etc/mkinitcpio.conf')
        print(pr.stdout.decode(), end='')
    if compression:
        pr = rc.execute(
            '/usr/bin/grep', '^COMPRESSION=', '/etc/mkinitcpio.conf')
        print(pr.stdout.decode(), end='')


def chkpacman(terminal, siglevel=False):
    """Print certain settings of the /etc/pacman.conf"""
    print('Checking /etc/pacman.conf on', terminal, file=stderr)
    rc = RemoteController('termgr', terminal)
    if siglevel:
        pr = rc.execute(
            '/usr/bin/grep', '^SigLevel', '/etc/pacman.conf')
        print(pr.stdout.decode(), end='')


if __name__ == '__main__':
    options = docopt(__doc__)
    if geteuid() == 0:
        print('Refusing to run as root')
        exit(3)
    elif getuser() != USER:
        print('You must be {0} to run {1}'.format(USER, __file__), file=stderr)
        exit(2)
    else:
        USER = options['--user'] if options['--user'] else USER
        VERBOSE = options['--verbose']
        # Get terminals generator
        if not options['<expr>']:
            terminals = Terminal.select().where(
                ~(Terminal.deployed >> None) &
                (Terminal.testing == 0))
        else:
            terminals = TerminalFilter(options['<expr>'])
        # Filter out undeployed terminals
        if not options['--undeployed']:
            terminals = deployed(terminals)
        if options['upgrade']:
            parallelize(target=upgrade, args=itemize(terminals))
        elif options['reboot']:
            parallelize(target=reboot, args=itemize(terminals))
        elif options['unlock']:
            parallelize(target=rm_pacman_lock, args=itemize(terminals))
        elif options['chkres']:
            for terminal in online(terminals):
                chkres(terminal)
        elif options['fixpkg']:
            packages = options['<pkgs>']
            for terminal in online(terminals):
                fixpkg(terminal, packages=packages)
        elif options['chkinitcpio']:
            modules = options['--modules']
            hooks = options['--hooks']
            compression = options['--compression']
            for terminal in online(terminals):
                chkinitcpio(
                    terminal, modules=modules, hooks=hooks,
                    compression=compression)
        elif options['chkpacman']:
            siglevel = options['--siglevel']
            for terminal in online(terminals):
                chkpacman(terminal, siglevel=siglevel)
