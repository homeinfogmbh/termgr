#! /usr/bin/env python3
"""Command line tool to administer HOMEINFO terminals

Usage:
    termadm add <class_id> <cid> <os> [<street> <house_number> <zip_code> \
<city> [--state=<state_iso>] [--address-annotation=<address_annotation>]] \
[options]
    termadm addall <cid> <file> [--class=<class>] [--os=<os>] [options]
    termadm deploy <expr>... [--date=<date_string> [--format=<date_format>]] \
[--force] [--no-reload]
    termadm undeploy <expr>... [--no-reload]
    termadm relocate <terminal> <street> <house_number> <zip_code> <city> \
[--state=<state_iso>] [--no-reload]
    termadm permit <user> [<permissions> <expr>...]

Options:
    -h --help                   Show this screen.
    --version                   Show version.
    --domain=<domain>           Specify the domain [default: 1].
    --connection=<connection>   Specify connection type [default: 1].
    --tid=<tid>                 Explicitly select a TID (not recommended!).
    --key=<key>                 Explicitly specify an OpenVPN key to be used.
    --annotation=<annotation>   Specify an annotation for this terminal.
    --no-reload                 Do not reload services after terminal creation.
    --class=<class>             Specifies the termianl class [default: 3].
    --os=<os>                   Specifies the termianl class [default: 1].
    --weather=<weather>         Specifies the weather to use.
"""

from os import geteuid
from sys import stderr
from os.path import basename
from itertools import chain
from datetime import datetime
from logging import INFO, getLogger, basicConfig

from homeinfo.lib.system import run, evaluate
from homeinfo.crm import Address, State
from homeinfo.terminals.orm import Class, Domain, OS, VPN, Connection, \
    Location, Terminal
from homeinfo.terminals.filter import TerminalFilter

from termgr.lib.permissions import PermissionsParser, UserPermissions
from termgr.orm import PermissionError, User, Permissions


def update_nagios():
    """Generates the Nagios3 configuration"""

    print('Creating Nagios3 configurations', end='         ', flush=True)
    evaluate(run('/usr/bin/nagioscfg-gen'))


def update_config():
    """Fix stuff after operations"""

    print('Generating bind9 configuration', end='          ', flush=True)
    evaluate(run('/usr/bin/bindcfg-gen'))

    print('Generating OpenVPN host configurations', end='  ', flush=True)
    evaluate(run('/usr/bin/openvpncfg-gen'))
    update_nagios()


def read_file(path):
    """Read address information from file"""

    with open(path, 'r') as f:
        for line in f:
            sline = line.strip()

            if sline:
                if not sline.startswith('#'):
                    yield sline


def parse_address(string, sep=' '):
    """Parses an address from a string"""

    elements = [e for e in string.split(sep) if e]

    try:
        *street, house_number, zip_code, city = elements
    except ValueError:
        raise ValueError('Not an address: {}'.format(string))
    else:
        return (city, (sep.join(street), house_number, zip_code))


if __name__ == '__main__':
    from docopt import docopt

    logger = getLogger(basename(__file__))
    options = docopt(__doc__)

    basicConfig(level=INFO)

    try:
        reload = not options['--no-reload']
    except KeyError:
        reload = False

    # Bail out iff reload of services
    # is required, but we are not root.
    if options['add'] or options['deploy'] or options['undeploy']:
        if reload and geteuid() != 0:
            print('You must be root to update the related services')
            exit(3)

    # Add new terminal
    if options['add']:
        # Required options
        tid = int(options['--tid']) if options['--tid'] else None
        cid = int(options['<cid>'])
        class_id = int(options['<class_id>'])
        os_id = int(options['<os>'])

        # Optional settings
        connection_id = int(options['--connection'])
        domain_id = int(options['--domain'])
        weather = options['--weather'] or None

        # Optional address
        street = options['<street>']
        house_number = options['<house_number>']
        zip_code = options['<zip_code>']
        city = options['<city>']
        state_iso = options['--state']
        address_annotation = options['--address-annotation']

        if street:
            addr = (street, house_number, zip_code)
        else:
            addr = None

        # Optional parameters
        vpn_key = options['--key'] or None
        annotation = options['--annotation'] or None

        # Get related ORM instances
        class_ = Class.get(Class.id == class_id)
        os = OS.get(OS.id == os_id)
        connection = Connection.get(Connection.id == connection_id)

        if vpn_key is not None:
            logger.warning(
                'Divergent OpenVPN key specified: "{}"!'.format(vpn_key))

        vpn = VPN.add(key=vpn_key)
        domain = Domain.get(Domain.id == domain_id)

        if addr is not None:
            address = Address.add(city, addr=addr, state=None)
            location = Location.add(address, annotation=address_annotation)
        else:
            location = None

        # Add new terminal
        terminal = Terminal.add(
            cid, class_, os, connection, vpn, domain,
            location=location, weather=weather, tid=tid)

        if terminal:
            logger.info('Added terminal {}'.format(terminal))
        else:
            logger.error('Failed to add terminal')

        if reload:
            update_config()

    # Add new terminal
    elif options['addall']:
        # Required options
        cid = int(options['<cid>'])
        path = options['<file>']
        class_id = int(options['--class'])
        os_id = int(options['--os'])
        connection_id = int(options['--connection'])
        domain_id = int(options['--domain'])
        weather = options['--weather'] or None

        # Get ORM references
        class_ = Class.get(Class.id == class_id)
        os = OS.get(OS.id == os_id)
        connection = Connection.get(Connection.id == connection_id)
        domain = Domain.get(Domain.id == domain_id)

        for line in read_file(path):
            try:
                city, addr = parse_address(line)
            except ValueError:
                logger.error('Not an address: {}'.format(line))
            else:
                # Generate unique VPN connection
                vpn = VPN.add()

                # Add location
                address = Address.add(city, addr=addr, state=None)
                location = Location.add(address)

                # Add new terminal
                terminal = Terminal.add(
                    cid, class_, os, connection, vpn, domain,
                    location=location, weather=weather)

                if terminal:
                    logger.info('Added terminal {}'.format(terminal))
                else:
                    logger.error('Failed to add terminal')

        if reload:
            update_config()


    # Deploy terminal
    elif options['deploy']:
        date_string = options['--date']
        force = options['--force']

        if date_string:
            date_format = options['--format'] or '%Y-%m-%d'

            try:
                date_time = datetime.strptime(date_string, date_format)
            except ValueError:
                logger.error(
                    'Invalid date time value ({date_string}) '
                    'or format ({date_format})'.format(
                        date_string=date_string, date_format=date_format))
                exit(4)
        else:
            date_time = None

        for expr in options['<expr>']:
            for terminal in TerminalFilter(expr):
                terminal.deploy(date_time=date_time, force=force)

        if reload:
            update_nagios()

    # Undeploy terminal
    elif options['undeploy']:
        for expr in options['<expr>']:
            for terminal in TerminalFilter(expr):
                terminal.undeploy()

        if reload:
            update_nagios()

    # Relocate a terminal
    elif options['relocate']:
        terminals = [t for t in TerminalFilter(options['<terminal>'])]

        if len(terminals) != 1:
            print('Can only relocate one terminal at a time')
            exit(1)
        else:
            terminal = terminals[0]

            street = options['<street>']
            house_number = options['<house_number>']
            zip_code = options['<zip_code>']
            city = options['<city>']
            state_iso = options['--state']

            addr = street, house_number, zip_code

            # Get state
            if state_iso:
                try:
                    state = State.get(State._iso == state_iso)
                except DoesNotExist:
                    print('No such state:', state_iso)
                    exit(1)
            else:
                state = None

            address = Address.add(city, addr=addr, state=state)
            if terminal.location.address == address:
                print(terminal, 'is already located at', repr(address))
            else:
                terminal.location.address = address

                if terminal.location.save():
                    print('Moved', terminal, 'to', repr(address))
                else:
                    print('Failed to move', terminal, 'to', repr(address))
                    exit(1)

    # Set user permissions
    elif options['permit']:
        user = User.get(User.name == options['<user>'])

        if options['<permissions>'] is None:
            permissions = UserPermissions(user)
            print(permissions)
        else:
            permissions = PermissionsParser(options['<permissions>'])

            for expr in options['<expr>']:
                for terminal in TerminalFilter(expr):
                    try:
                        user.permit(
                            terminal,
                            read=permissions.read,
                            administer=permissions.administer,
                            setup=permissions.setup)
                    except PermissionError as e:
                        logger.warning(e.msg)
