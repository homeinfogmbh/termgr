#! /usr/bin/env python3
"""Command line tool to administer HOMEINFO terminals

Usage:
    termadm add <class_id> <cid> <os> [<street> <house_number> <zip_code> \
<city> [--state=<state_iso>] [--address-annotation=<address_annotation>]] \
[options]
    termadm deploy <expr>... [--date=<date_string> [--format=<date_format>]] \
[--force] [--no-reload]
    termadm undeploy <expr>... [--no-reload]
    termadm relocate <terminal> <street> <house_number> <zip_code> <city> \
[--state=<state_iso>] [--no-reload]
    termadm permit <user> [<permissions> <expr>...]

Options:
    -h --help                   Show this screen.
    --version                   Show version.
    --domain=<domain>           Specify the domain [default: 1].
    --connection=<connection>   Specify connection type [default: 1].
    --tid=<tid>                 Explicitly select a TID (not recommended!).
    --key=<key>                 Explicitly specify an OpenVPN key to be used.
    --annotation=<annotation>   Specify an annotation for this terminal.
    --no-reload                 Do not reload services after terminal creation.
"""

from os import geteuid
from sys import stderr
from os.path import basename
from itertools import chain
from datetime import datetime
from logging import INFO, getLogger, basicConfig
from json import dumps

from docopt import docopt

from homeinfo.lib.system import run, evaluate
from homeinfo.lib.permissions import parse
from homeinfo.crm import Address, State
from homeinfo.terminals.orm import Class, Domain, OS, VPN, Connection, \
    Location, Terminal
from homeinfo.terminals.filter import TerminalFilter

from termgr.orm import PermissionError, User, Permissions


def update_nagios():
    """Generates the Nagios3 configuration"""

    print('Creating Nagios3 configurations', end='         ', flush=True)
    evaluate(run('/usr/lib/terminals/nagioscfg-gen'))


def update_config():
    """Fix stuff after operations"""

    print('Generating bind9 configuration', end='          ', flush=True)
    evaluate(run('/usr/lib/terminals/bindcfg-gen'))

    print('Generating OpenVPN host configurations', end='  ', flush=True)
    evaluate(run('/usr/lib/terminals/openvpncfg-gen'))
    update_nagios()





def permdict(user):
    """Order permissions of the respective user in a dictionary"""

    permissions = {}

    for permission in Permissions.select().where(Permissions.user == user):

        cid = permission.terminal.customer.id
        tid = permission.terminal.tid

        try:
            tids = permissions[cid]
        except KeyError:
            permissions[cid] = tids = {}

        try:
            permission_ = tids[tid]
        except KeyError:
            tids[tid] = permission
        else:
            if permission > permission_:
                tids[tid] = permission

    return permissions


def frmt_perms(d, human_readable=True):
    """Formats the respective permissions dictionary"""

    permission_groups = {}

    # Group by permissions
    for cid in d:
        tids = d[cid]

        for tid in sorted(tids):
            permission = tids[tid]

            if human_readable:
                perm = str(permission)
            else:
                perm = repr(permission)

            try:
                cids_ = permission_groups[perm]
            except KeyError:
                cids_ = permission_groups[perm] = {}

            try:
                tid_ranges = cids_[cid]
            except KeyError:
                tid_ranges = cids_[cid] = []

            # Derive TID ranges like [<start>, <end>]
            for tid_range in tid_ranges:
                if tid_range[-1] == tid - 1:
                    tid_range.append(tid)
                    break
            else:
                tid_ranges.append([tid])

    # Format TID ranges
    for permission in permission_groups:
        cids = permission_groups[permission]

        for cid in cids:
            tid_ranges = cids[cid]

            all_tids = set(
                terminal.tid for terminal in
                Terminal.select().where(Terminal.customer == cid))
            my_tids = set(chain(*tid_ranges))

            if all_tids == my_tids:
                str_ranges = 'all'
            else:
                str_ranges = []

                for tid_range in tid_ranges:
                    if len(tid_range) == 2:
                        str_range = '{start}-{end}'.format(
                            start=tid_range[0], end=tid_range[-1])
                    elif len(tid_range) == 1:
                        str_range = str(tid_range[0])
                    else:
                        raise ValueError(
                            'Unexpected TID range: {}'.format(tid_range))

                    str_ranges.append(str_range)

            cids[cid] = str_ranges

    return permission_groups


if __name__ == '__main__':
    logger = getLogger(basename(__file__))
    options = docopt(__doc__)

    basicConfig(level=INFO)

    try:
        reload = not options['--no-reload']
    except KeyError:
        reload = False

    # Bail out iff reload of services
    # is required, but we are not root.
    if options['add'] or options['deploy'] or options['undeploy']:
        if reload and geteuid() != 0:
            print('You must be root to update the related services')
            exit(3)

    # Add new terminal
    if options['add']:
        # Required options
        tid = int(options['--tid']) if options['--tid'] else None
        cid = int(options['<cid>'])
        class_id = int(options['<class_id>'])
        os_id = int(options['<os>'])

        # Optional settings
        connection_id = int(options['--connection'])
        domain_id = int(options['--domain'])

        # Optional address
        street = options['<street>']
        house_number = options['<house_number>']
        zip_code = options['<zip_code>']
        city = options['<city>']
        state_iso = options['--state']

        if street:
            addr = (street, house_number, zip_code)
        else:
            addr = None

        address_annotation = options['--address-annotation']

        # Optional parameters
        vpn_key = options['--key'] or None
        annotation = options['--annotation'] or None

        # Get related ORM instances
        class_ = Class.get(Class.id == class_id)
        os = OS.get(OS.id == os_id)
        connection = Connection.get(Connection.id == connection_id)

        if vpn_key is not None:
            cls.logger.warning(
                'Divergent OpenVPN key specified: "{}"!'.format(vpn_key))

        vpn = VPN.add(key=vpn_key)
        domain = Domain.get(Domain.id == domain_id)

        if addr is not None:
            address = Address.add(city, addr=addr, state=None)
            location = Location.add(address, annotation=address_annotation)
        else:
            location = None

        # Add new terminal
        terminal = Terminal.add(
            cid, class_, os, connection, vpn, domain,
            location=location, tid=tid)

        if terminal:
            logger.info('Added terminal {0}'.format(terminal))
        else:
            logger.error('Failed to add terminal')

        if reload:
            update_config()

    # Deploy terminal
    elif options['deploy']:
        date_string = options['--date']
        force = options['--force']

        if date_string:
            date_format = options['--format'] or '%Y-%m-%d'

            try:
                date_time = datetime.strptime(date_string, date_format)
            except ValueError:
                logger.error(
                    'Invalid date time value ({0}) or format ({0})'.format(
                        date_string, date_format))
                exit(4)
        else:
            date_time = None

        for expr in options['<expr>']:
            for terminal in TerminalFilter(expr):
                terminal.deploy(date_time=date_time, force=force)

        if reload:
            update_nagios()

    # Undeploy terminal
    elif options['undeploy']:
        for expr in options['<expr>']:
            for terminal in TerminalFilter(expr):
                terminal.undeploy()

        if reload:
            update_nagios()

    # Relocate a terminal
    elif options['relocate']:
        terminals = [t for t in TerminalFilter(options['<terminal>'])]

        if len(terminals) != 1:
            print('Can only relocate one terminal at a time')
            exit(1)
        else:
            terminal = terminals[0]

            street = options['<street>']
            house_number = options['<house_number>']
            zip_code = options['<zip_code>']
            city = options['<city>']
            state_iso = options['--state']

            addr = street, house_number, zip_code

            # Get state
            if state_iso:
                try:
                    state = State.get(State._iso == state_iso)
                except DoesNotExist:
                    print('No such state:', state_iso)
                    exit(1)
            else:
                state = None

            address = Address.add(city, addr=addr, state=state)
            if terminal.location.address == address:
                print(terminal, 'is already located at', repr(address))
            else:
                terminal.location.address = address

                if terminal.location.save():
                    print('Moved', terminal, 'to', repr(address))
                else:
                    print('Failed to move', terminal, 'to', repr(address))
                    exit(1)

    # Set user permissions
    elif options['permit']:
        user = User.get(User.name == options['<user>'])

        if options['<permissions>'] is None:
            permissions = frmt_perms(permdict(user))
            print(dumps(permissions, indent=2))
        else:
            read, administer, setup = parse(options['<permissions>'])

            for expr in options['<expr>']:
                for terminal in TerminalFilter(expr):
                    try:
                        user.permit(
                            terminal,
                            read=read,
                            administer=administer,
                            setup=setup)
                    except PermissionError as pe:
                        logger.warning(pe.msg)
